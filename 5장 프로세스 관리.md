# 5장 프로세스 관리

## 프로세스(process)란 ?

**프로세스**란 **실행 중인 프로그램**을 뜻한다. 디스크에 실행파일 형태로 존재하던 프로그램이 메모리에 올라가서 실행되기 시작하면 비로소 생명력을 갖는 프로세스가 된다. 

## 프로세스 문맥(프로세스 컨텍스트)이란?

**프로세스가 현재 어떤 상태에서 수행되고 있는 지 정확히 규명하기 위해 필요한 정보를 의미**한다. 프로세스가 시작해서 종료할 때까지 CPU 에서 명령을 한꺼번에 수행하면 좋겠지만, 여러 프로세스가 함께 수행되는 시분할 시스템 환경에서는 타이머 인터럽트에 의해 짧은 시간 동안 CPU를 사용한 후 빼앗겼다가 추후에 다시 CPU를 획득하는 식으로 CPU 관리가 이루어진다. 따라서 **CPU를 다시 획득해 명령의 수행을 재개하는 시점이 되면 이전의 CPU 보유 시기에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태를 재현할 필요가 있다.** 이때 **정확한 재현을 위해 필요한 정보가 바로 프로세스의 문맥**이다. 

프로세스 문맥은 그 프로세스의 주소 공간(코드, 데이터, 스택 상태), 레지스터에 어떤 값을 갖고 있었는지, 시스템 콜 등을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함한다. 

## 프로세스 문맥의 종류 3가지

### 하드웨어 문맥 (컴퓨터 철덩어리)

- CPU의 수행 상태를 나타낸다.
- 프로그램 카운터값, 각종 레지스터에 저장하고 있는 값들을 의미

### 프로세스의 주소 공간

- 프로세스의 코드, 데이터, 스택
- 프로세스는 자기 자신만의 독자적인 주소 공간을 가지고 있다.

### Code(Text) 영역 : 컴파일 타임에 할당
- 프로그램의 소스코드가 위치하는 영역이다.
- 형태는 Hex 또는 binary로 기계어다.
- CPU는 코드 영역에 위치한 명령어를 하나씩 가져와서 처리한다.


### Data 영역 : 컴파일 타임에 할당
- 전역(global) 변수와 정적(static) 변수가 위치하는 영역이다.
- 프로그램의 시작과 동시에 할당되고 프로그램이 종료되어야 메모리에서 소멸된다.
- 데이터 영역에는 BSS(Block Stated Symbol)라는 영역이 존재한다.
- 초기화 되지 않거나, 초기화를 0으로 하거나, 초기화를 NULL로한 전역 변수와 정적 변수는 BSS 영역에 위치한다.
- BSS라는 영역이 왜 존재할까? 이는 공간을 효율적으로 활용하기 위해서다.
- 아래 코드를 보자. 배열 a의 크기는 400000 바이트다. 하지만 선언만하고 값이 들어있지 않기에 굳이 400000 바이트라는 공간을 할당할 필요가 없다. 따라서 a 배열의 크기와 이름에 대한 정보는 BSS에 올려서 공간을 효율적으로 활용한다.



### Heap 영역 : 런타임에 할당
- 프로그래머에 의해 메모리 공간이 동적으로 할당되고 해제되는 영역이다.
- C언어의 malloc(), free() 등의 함수를 생각해보자.
- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.


### Stack 영역 : 런타임에 할당
- 지역(local) 변수와 매개 변수(parameter)가 위치하는 영역이다.
- 함수의 호출과 동시에 할당되고 함수의 호출이 완료되면 메모리에서 소멸된다.
- 함수가 호출되면 push 되고 함수가 종료되면 pop 되는 것이다.
- 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- 컴파일 타임은 소스코드가 컴파일이라는 과정을 통해 기계어 코드로 변환되어 실행 가능한 프로그램이 되는데 걸리는 시간이다.
- 런타임은 컴파일 과정을 마친 기계어 형태의 프로그램이 실행되는 시간이다. 즉, 프로그램이 동작되는 시간이다.



### 커널(운영체제의 프로세스)상의 문맥

- 프로그램이 수행되어 프로세스가 되면 운영체제는 프로세스를 관리하기 위한 자료구조를 유지한다.
- PCB, 커널 스택이 '커널 상의 문맥'을 구성한다.

## 프로세스의 상태

### 시작 상태 (new)

프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만, 아직 메모리 획득을 승인받지 못한 상태

### 실행 상태 (running)

프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태

### 준비 상태 (ready)

프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태를 가리킨다. 

### 봉쇄 상태 (waiting, blocked)

CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태를 말한다. 봉쇄 상태의 예로는 프로세스가 요청한 입출력 작업이 진행 중인 경우를 들 수 있다. 

### 완료 상태 (terminated)

프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태를 말한다. 

> 하나의 프로세스는 항상 앞서 설명한 상태 중의 어느 한 상태에 머물러 있게 된다. 그리고 그 상태는 시간이 흐름에 따라 변하게 된다.

## 프로세스의 생성

운영체제가 프로세스 전부를 생성한다고 생각할 수 있지만 사실은 그렇지 않다. 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다. 

이 때 프로세스를 생성한 프로세스를 **부모 프로세스**라고 하고, 새롭게 생성된 프로세스를 **자식 프로세스**라고 한다. 즉 부모 프로세스가 자식 프로세스를 생성하게 되는 것이다. 이러한 방식을 통해 **프로세스는 족보와 같은 계층을 형성**하게 된다. 프로세스의 세계에서는 자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식으로 진행된다. 만약 후손들을 여러 단계에 걸쳐 많이 생성한 프로세스가 종료될 경우에는 그 프로세스가 생성했던 모든 후손 프로세스들을 연쇄적으로 종료시키니 후에야 본인이 종료될 수 있다. 

프로세스가 생성되면 자신만의 독자적인 주소 공간을 갖게 된다. **부모 프로세스가 자식 프로세스를 생성하면 부모 프로세스와는 별도의 주소 공간을 가지게 되는데, 처음 주소 공간을 생성할 때에는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다**. 자식 프로세스가 다른 프로그램을 수행하기 위해서는 생성된 주소 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워 실행하게 되는 것이다. 즉, 프로세스 ID를 제외한 모든 정보(운영체제 커널 내의 정보와 주소 공간의 정보)를 그대로 복사하는 방법을 사용한다. 따라서 부모 프로세스와 자식 프로세스는 비록 주소 공간을 따로 갖게 되지만 주소 공간 내에는 동일한 내용을 가지게 된다. 

## 문맥교환 (컨텍스트 스위치, context switch)

### 문맥교환이란?

실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 의미한다. 즉, 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다. 

### 문맥 교환이 일어나는 경우

1. 타이머 인터럽트가 발생하는 경우

    → 타이머 인터럽트에 의해 **다른 프로세스로 바뀌게 된다.** 

2. 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태로 바뀌는 경우

    → 입출력 요청으로 인해 봉쇄 상태로 바껴서 **다른 프로세스로 바뀌게 된다.**

> **다른 프로세스로 바뀌어야만 '문맥 교환'이 일어난다!!**

****참고)** 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 '**CPU 디스패치**'라고 한다. 

### 문맥 교환 과정
- 시스템 콜이나 인터럽트가 발생하여 커널의 호출이 필요한 상황이 나타난다.
- 프로그램 카운터와 레지스터 값 등 문맥 정보를 커널에 있는 해당 프로세스의 PCB에 저장한다.
- 현재 프로세스의 상태를 바꿔준다. (running -> blocked or ready or exit)
- 프로세스의 상태에 따라 PCB를 적절한 큐에 넣어준다. (블록큐, 레디큐 등)
- 다음에 수행시킬 다른 프로세스를 선택한다.
- 선택된 프로세스의 상태를 running으로 바꿔준다.
- 선택된 프로세스의 문맥 정보를 복구한다.
- CPU는 새롭게 선택된 프로세스를 수행한다.


### '타이머 인터럽트'로 인해 문맥 교환이 일어나는 과정

사용자 프로세스가 CPU를 할당받고 실행되던 중에 타이머 인터럽트가 발생하면 CPU의 제어권은 운영체제에게 넘어가게 된다. 그러면 운영체제는 타이머 인터럽트 처리루틴으로 가서 직전까지 수행 중이던 프로세스의 문맥을 저장하고 새롭게 실행시킬 프로세스에게 CPU를 이양한다. 이 과정에서 원래 수행 중이던 프로세스는 준비 상태로 바뀌고, 새롭게 CPU를 할당받은 프로세스는 실행 상태가 된다. 문맥교환 중에 원래 CPU를 보유하고 있던 프로세스는 프로그램 카운터값 등 프로세스 문맥을 자신의 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시키는 과정을 거친다. 

### 주의) 프로세스가 바뀌지 않으면 '문맥 교환'이라고 하지 않는다.

프로세스가 실행 상태일 때, 시스템 콜이나 인터럽트가 발생하면 CPU의 제어권이 운영체제로 넘어와 원래 실행 중이던 프로세스의 업무를 잠시 멈추고 운영체제 커널의 코드가 실행된다. 이 경우에도 CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PCB에 저장하게 되지만 이러한 과정을 문맥교환이라 하지 않는다. 이는 하나의 프로세스의 실행 모드만이 사용자 모드에서 커널모드로 바뀌는 것일 뿐(**모드 변경**), CPU를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 때문이다. 즉, 다른 프로세스로 바꾸는 과정이 없기 때문에 문맥 교환이 일어나지 않는다.

타이머 인터럽트가 발생하거나 프로세스가 입출력 요청 시스템 콜을 하여 봉쇄 상태에 들어가는 경우에는 문맥교환이 일어나지만, 그 밖의 인터럽트나 시스템 콜 발생 시에는 **문맥 교환이 일어나지 않고 실행 모드만이 변경**될 뿐이다. 즉 사용자모드에서 커널모드로 바뀌어 시스템 콜이나 인터럽트 처리를 하고, **다시 동일한 프로세스의 사용자모드로 돌아와 이전에 수행하던 작업을 계속 수행할 뿐**이다. 

### 문맥교환의 비용

위에서 언급한 '모드 변경'에 비해 '문맥 교환'은 훨씬 많은 오버헤드가 뒤따르게 된다. 문맥 교환에 소요되는 시간은 시스템 입장에서 볼 때 일종의 헤드라고 할 수 있다. 따라서 타이머에 CPU 할당시간을 아주 작게 세팅해 프로세스 간 문맥교환이 빈번하게 발생하도록 하면 이에 드는 오버헤드가 상당히 커진다. 또 그 반대로 CPU 할당시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색하게 되므로 적절한 CPU 할당시간을 정하는 것이 중요하다. 

## 입출력을 요청한 프로세스의 상태 변화

특정 프로세스가 실행 상태에 있다고 가정하자. 즉, 프로세스는 CPU를 할당받고 기계어 명령을 하나씩 수행해나가고 있다. 그런데 경우에 따라서는 디스크에서 파일의 내용을 읽어와야 하는 명령이 포함될 수 있다. 그럴 경우 읽어온  결과가 있어야 후속 명령을 수행할 수 있는데, 디스크에서 읽는 작업은 CPU 처리 속도에 비해 상대적으로 오랜 시간이 소요되는 작업이기 때문에 디스크 입출력이 진행되는 동안에는 이 프로세스가 CPU를 점유하고 있어도 후속 명령을 처리하지 못해서 CPU가 비효율적으로 낭비될 수 있다. 따라서 **입출력이 완료될 때까지 CPU를 반환한 다음, 디스크 입출력 서비스를 기다리며 봉쇄 상태로 바뀌게 된다. 그러면 CPU를 기다리는 준비 상태의 프로세스들 중에서 CPU 스케줄러가 적절한 프로세스를 하나 선정해 CPU를 할당하게 된다.** 준비 상태의 프로세스는 CPU만 획득하면 곧바로 명령을 수행할 수 있으므로 이번에 CPU를 할당받은 프로세스는 실행 상태로 변경되어 자신의 코드를 CPU에서 실행하게 된다. 

> 디스크 입출력을 요청한 프로세스는 그 후 어떠한 상태 변화를 겪게 되는 것일까?

1. 입출력을 요청한 프로세스는 디스크 입출력을 기다리는 큐에 줄 서 있다가 자기 차례가 되어 디스크 컨트롤러로부터 서비스를 받고 나면(즉 마그네틱 매체에서 원하는 데이터를 로컬버퍼로 읽어오고 나면) 디스크 컨트롤러가 CPU에게 인터럽트를 발생시켜 입출력이 완료되었다는 사실을 알린다. 
2. 그러면 CPU는 어떤 프로세스를 실행하고 있다가 인터럽트가 발생한 것을 확인하고 그에 대응하는 루틴을 수행한다. 이 루틴이 진행되는 동안 CPU에서 수행되던 프로세스의 상태는 사용자모드 실행 상태에서 커널모드 실행 상태로 바뀐다. 비록 인터럽트 처리 루틴이 직전에 실행 중이던 프로세스와는 무관한 업무를 담고 있기는 하지만 인터럽트 처리를 우리는 편의상 직전 프로세스의 문맥에서 실행된 것으로 간주한다. 다시 말해 프로세스가 실행되던 중에 인터럽트가 발생하면, 인터럽트가 발생한 원인과 관계없이 인터럽트를 당한 프로세스가 사용자모드에서 실행되다가 커널모드로 진입한 것으로 간주하게 된다는 것이다.
3. 디스크 컨트롤러가 발생시킨 인터럽트의 출력이 완료된 프로세스의 상태를 봉쇄 상태에서 준비 상태로 바꾼 후 장치의 로컬버퍼에 있는 내용을 메모리로 이동시키는 일련의 업무를 수행한다. 
4. 이렇게 인터럽트 처리가 끝나면 인터럽트 처리루틴 이전에 수행되던 프로세스에게 CPU를 다시 할당해 그 프로세스의 직전 수행 시점 이후의 코드가 실행된다.

    경우에 따라서는 인터럽트 당한 프로세스에게 CPU를 다시 할당하지 않고, 입출력이 완료된 프로세스가 더 우선순위가 높은 프로세스인 경우 문맥교환을 통해 CPU 제어권을 이야시킬 수도 있다. 즉, 인터럽트 발생 전에 수행되던 프로세스가 아니라 방금 입출력을 끝낸 프로세스에게 CPU를 할당하는 경우도 있다는 것이다.

## 프로세스를 스케줄링하기 위한 큐

**프로세스의 상태 관리는** 커널 주소 영역 중 **데이터 영역에 다양한 큐를 두어 수행**하게 된다. 각 프로세스가 CPU를 기다리는 지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리한다는 뜻이다. 예를 들어 타이머 인터럽트가 발생하면 커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해 다음에 어느 프로세스에게 CPU를 할당할 지 결정하고, 현재 실행 중인 프로세스는 준비 큐의 제일 뒤로 보낸다. 

### 준비 큐 (ready queue)

운영체제는 **준비 상태에 있는 프로세스들을 줄 세우기 위해** **준비 큐(ready queue)**를 두고, 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다. 

### 장치 큐 (device queue)

**특정 자원을 기다리는 프로세스들을 줄 세우기 위해** 자원별로 **장치 큐(device queue)**를 둔다. 예를 들어 디스크에 입출력 서비스를 요청한 프로세스들은 '**디스크 입출력 큐**'에 줄 서게 된다. 그러면 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행한다. 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에 인터럽트를 발생시키게 되고, 그러면 인터럽트 처리루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 **준비 큐**에 줄 서게 된다. 디스크 입출력 큐 외에도 프로그램이 키보드로부터 어떤 입력을 받아야 하는 경우에는 '**키보드 입출력 큐'**에 줄 서게 되며, 화면이 프린터에 처리 결과를 출력해야 하는 경우에는 각각 해당 '**입출력 큐'**에 줄 서게 된다. 

### 작업 큐 (job queue)

**작업 큐**는 **시스템 내의 모든 프로세스를 관리하기 위한 큐**로, 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속하게 된다. 그러므로 작업 큐에 있다고 해서 반드시 메모리를 가지고 있는 것이 아니다. 준비 큐에 속한 프로세스들은 준비 상태에 있고, 장치 큐에 속한 프로세스들은 봉쇄 상태에 있으므로 프로세스는 상태 변화에 따라 준비 큐와 장치 큐를 오가며 실행된다. 작업 큐가 가장 넓은 개념이고, 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업 큐에 속해 있다. 

장치 큐는 각각의 자원마다 큐가 하나씩 존재한다. 프로세스가 CPU를 할당받고 코드를 수행하다가 입출력 요청이 발생하면 해당 장치 큐에 가서 줄을 서게 된다. 장치 큐에 속한 프로세스들은 봉쇄 상태에 있다가 해당 장치의 서비스를 받고 나서 장치 컨트롤러가 인터럽트를 발생시키면 준비 상태로 바뀌어 준비 큐로 이동한다.

## 프로세스 제어블록(Process Control Block: PCB)이란?

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다.

## PCB 구성 요소

- 프로세스의 상태 : CPU를 할당해도 되는 지 여부를 결정
- 프로그램 카운터값 : 다음에 수행할 명령의 위치를 가리킴
- CPU 레지스터값 : CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타냄
- CPU 스케줄링 정보 : CPU 스케줄링에 필요한 정보
- 메모리 관리 정보 : 메모리 할당을 위해 필요한 정보
- 자원 사용 정보 : 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용
- 입출력 상태 정보 : 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보


## 스케줄러란?

어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.

## 스케줄러 종류

### 장기 스케줄러

- (= 작업 스케줄러)
- **어떤 프로세스를 준비 큐에 진입시킬 지 결정**하는 역할을 한다. 처음 프로세스가 생성되면 시작 상태를 거쳐 준비 상태에 이르게 되는데, 장기 스케줄러는 이때 **시작 상태의 프로세스들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지 결정**하는 역할을 하게 되는 것이다.
- 준비 큐는 CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합이고, CPU에서 실행되기 위해서는 프로세스가 메모리를 보유해야 하므로 장기 스케줄러는 **프로세스에게 메모리를 할당하는 문제에 관여**하게 된다.
- **메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할**을 한다.
- 현대 운영체제에서는 장기 스케줄러를 사용하지 않는다. 장기 스케줄러는 과거의 적은 양의 메모리였을 때 사용했었다. 따라서 **현대에서는 프로세스가 시작되면 장기 스케줄러 없이 곧바로 프로세스에 메모리를 할당해 준비 큐에 넣어준다.**

### 단기 스케줄러

- (= CPU 스케줄러)
- **준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정**한다. **준비 큐에 있는 여러 프로세스들 중 어떠한 프로세스에게 CPU를 할당할 것인가를 단기 스케줄러가 결정**하게 된다. 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.

> **중간 정리
> - 장기 스케줄러**에 의해 프로세스가 **시작 상태**에서 준비 큐에 삽입되어서 **준비 상태**가 된다.
> - **단기 스케줄러**에 의해 **준비 상태**에서 **실행 상태**가 된다.

### 중기 스케줄러

- **너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우, 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절**하기 위해 추가된 스케줄러이다.
- 만약 너무 많은 프로세스가 메모리에 적재되어 프로세스당 보유하고 있는 메모리양이 극도로 적어지면, CPU 수행에 당장 필요한 프로세스의 주소 공간조차도 메모리에 올려놓기 어려운 상황이 발생한다. 그렇게 되면 스왑이 많이 일어나서 디스크 입출력이 수시로 발생하게 되고, 그로 인해 시스템의 성능이 심각하게 저하될 수 있다.

    중기 스케줄러는 이런 경우 **메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장**해둔다. 이와 같은 행위를 **스왑 아웃(swap out)**이라고 부른다. 

- **일부 프로세스를 메모리에서 디스크로 스왑 아웃시켜야 하는 경우 그 0순위인 프로세스는 봉쇄 상태에 있는 프로세스들**이다. 이는 봉쇄 상태인 프로세스들의 경우 당장 CPU를 획득할 가능성이 없기 때문에 메모리를 보유하고 있는 것 또한 큰 의미가 없기 때문이다.

## IPC 탄생 배경

프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다. 따라서 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다. 

하지만 경우에 따라서는 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있다. 이는 부분적인 처리 결과나 정보를 공유할 수 있고, 처리 속도가 향상될 수도 있는 등 여러 가지 측면에서 효과적일 수 있다. 따라서 **운영체제는 프로세스 간의 협력 메커니즘을 제공해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있게 한다.** 

## IPC란?

프로세스 간의 협력 메커니즘을 위해 운영체제가 제공하는 대표적인 메커니즘으로는 IPC가 있다. **IPC**란, **하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신**을 말한다. 이러한 통신에서는 **의사소통 기능**과 함게 **동기화**를 보장해주어야 한다. 공유 데이터를 서로 다른 두 프로세스가 사용할 수 있다고 하면 데이터의 불일치 문제가 발생할 수 있기 때문이다. 그러므로 하나의 프로세스가 공유 데이터의 값을 변경하는 동안 다른 프로세스는 그 데이터에 접근할 수 없게 해야 한다. 즉 IPC는 프로세스들 간의 통신과 동기화를 이루기 위한 메커니즘을 의미한다. 

## IPC 방법 2가지

IPC의 대표적인 방법으로는 '메시지 전달 방식'과 '공유메모리 방식'이 있다. 이 두 방식의 차이는 **프로세스 사이에 공유 데이터를 사용하는가, 그렇지 않는가에 있다.** 

### 메시지 전달 방식

프로세스 간에 공유 데이터를 일체 사용하지 않고, 메시지를 주고받으면서 통신하는 방식이다. 이때 두 프로세스의 주소 공간이 다르므로 메시지 전달을 직접 할 수는 없으며 커널이 그 역할을 하게 된다. **프로세스는 전달할 메시지를 운영체제에게 시스템 콜 방식으로 요청해 전달**할 수 있다. **메시지를 프로세스끼리 직접 주고 받을수 있다면 원하지 않는 메시지를 전달해 다른 프로세스에 악영향을 미칠 수 있으므로 운영체제는 메시지를 주고받는 연산을 특권명령으로 규정해 커널을 통해서만 가능하도록 하고 있다.** 

### 메시지 전달 방식 - 직접 통신
- 직접통신에서는 통신하려는 프로세스의 이름을 명시한다.
- send(p, message) : 프로세스 p에게 메세지를 전송하는 것을 의미한다.
- receive(Q, message) : 프로세스 Q로부터 메세지를 전달 받는 것을 의미한다.

### 메시지 전달 방식 - 간접 통신
- 간접통신에서는 메세지를 메일 박스 또는 포트로부터 전달 받는다.
- 각 메일박스에는 고유 ID가 있으며 메일 박스를 공유하는 프로세스들만 서로 통신할 수 있다.
- 간접 통신에서 사용되는 커뮤니케이션 링크는 여러 프로세스 간에 메일 박스를 공유하는 경우에만 생성된다.
- 하나의 링크가 여러 프로세스들에게 할당될 수 있고, 각 프로세스의 쌍은 여러 링크를 공유할 수 있다.
- send(A, message) : A라는 메일박스에 메세지를 전송한다.
- receive(A, message) : A라는 메일박스로부터 메세지를 전달 받는다.

### 공유 메모리 방식

공유메모리 방식에서는 프로세스들이 주소 공간의 일부를 공유한다. 원칙적으로 서로 다른 프로세스 A와 B는 각자 독립적인 주소 공간을 가지므로 프로세스 A가 자신의 주소 공간에 특정한 내용을 쓸 경우 이는 자신만 볼 수 있게 된다. 그러나 **운영체제는 공유메모리를 사용하는 시스템 콜을 지원해, 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록 한다. 이러한 공유메모리 영역은 각자의 주소 공간에 공통적으로 포함되는 영역이므로 여러 프로세스가 읽고 쓰는 것이 가능하다.**

공유메모리 방식은 프로세스 간의 통신을 수월하게 만드는 인터페이스를 제공하지만, 서로의 데이터 일관성 문제가 유발될 수 있다. 이에 대해서는 커널이 책임지지 않기 때문에 프로세스들끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야 한다.

